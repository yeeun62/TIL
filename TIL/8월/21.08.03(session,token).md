### 코드스테이츠 8월 3일

---

### CSRF

기존의 인증정보(쿠키)를 바탕으로 사용자가 어떤 변조된 서버를 믿어서 생기는 문제.
공격자 클라이언트가 이미 인증정보를 갖고 있는 쿠키를 가지고 피해자로 하여금 서버에 요청을 하게 유도하는 것.

1. 악성 스크립트가 담긴 사이트를 열거나 링크를 클릭할 때, 변조된 요청을 보내는 공격이다.
2. 기존의 로그인한 기록을 바탕으로 서버가 클라이언트의 요청을 믿기 때문에 발생한다.
3. sameSite 옵션을 none이 아닌 strict으로 바꾸어 CSRF 공격을 막을 수 있다.

XSS: code injection 공격 기법

### 세션

서버가 클라이언트에 유일하고 암호화된 id를 부여하고 중요데이터는 서버에서 관리한다.

- 내가 사이트에 보내는 정보들을 제 3자가 못 보게 한다. 암호화된 텍스트를 실어보낸다.
- 접속한 사이트가 믿을 만한 곳인지를 알려준다. 수상한 사이트를 걸러내줄 수 있게 한다.

### 토큰기반 인증

세션기반인증의 부담을 클라이언트에게 넘겨줄순 없을까에서 고안딨다.
대표적인 토큰 기반 인증 JWT
유저 정보를 암호화 한 상태로 담을 수 있고, 암호화했기 때문에 클라이언트에 담을 수 있다.

- 장점

1. statelessness & scalability(무상태성 & 확장성)
   서버는 클라이언트에 대한 정보를 저장할 필요가 없다.
   토큰을 헤더에 추가함으로 인증절차 완료
2. 안정성
   암호화 한 토큰을 사용
   암호화 키를 노출 할 필요가 없다.
3. 어디서나 생성 가능
   토큰을 생성하는 서버가 꼭 토큰을 만들지 않아도 된다.
4. 권한 부여에 용이
   토큰의 payload(내용물)안에 어떤 정보에 접근 가능한지
   ex) 사진 연락처 사용권한 부여/ 사진권한만부여

### JWT? (JSON Wen Token)

JSON 포맷으로 사용자에 대한 속성을 저장하는 웹 토큰이다.

- 구조

1. Header
   어떤 종류의 토큰인가?
   어떤 알고리즘으로 암호화 하는가?
2. Payload
   유저의 정보 (민감한 정보 안담는게 좋다.)
   권한을 부여 받았는가
   기타 필요한 정보
3. signature
   Header, payload를 base64인코딩한 값과 salt값의 조합으로 암호화된 값

- 어떻게 JWT는 스스로를 안전하다고 증명하는가?
  signature (서명)
  salt를 포함해서 토큰 암호화
  서버는 salt, 서명 검증(verify)을 할 수 있어야 한다.

- JWT 토큰을 어디다 저장할까?
  로컬스토리지 보다 쿠키가 더안전하다.

### 세션기반 인증

세션은 보통 하나의 서버에서만 접속 상태를 저장한다. 여러 개의 서버에서 같은 세션 데이터에 접근하려고 한다면 session clustering 혹은 공통 session store를 사용해야 하는 번거로움이 있다.(불가능한것은 아니다.)

1. 서버에 접속 상태가 저장된다.
2. 신뢰할 수 있는 유저인지 확인이 가능하다.
3. cookie에 세션 아이디가 저장된다.

세션기반 인증 대신 토큰기반 인증 사용을 고려한다면 다음과 같은 이유들이 있다.

1. 서버의 부담을 덜어주고
2. 여러개의 서버를 사용하는 서비스를 운영할때
3. 앱의 확장을 고려하고 있어서

### 세션과 토큰의 차이

세션인증과 토큰인증 가장 큰 차이 : 인증정보가 어디에 저장 되느냐

- 세션인증: 클라이언트(세션id가 담긴 쿠키) + 서버(세션 스토어)
  인증정보를 서버에도 담는 방법
- 토큰인증: 오직 클라이언트(쿠키, 로컬스토리지, jwt토큰)
  주고받는 내용 자체를 sign하는 방법

서버가 여러대일 경우(서비스 수평확장, 로드 밸런싱)
-> 토큰이 유리하다. 세션같은 경우는 인증정보를 여러 서버가 공유해야 하니까 복잡하다. 클라이언트로만 인증하면 서버의 부담이 없다.
