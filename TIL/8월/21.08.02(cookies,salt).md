### 코드스테이츠 8월 2일

---

### hash (부수다)

어떠한 문자열에 '임의의 연산'을 적용하여 다른 문자열로 변환하는 것.

원래값을 부수어(hash) 알아볼 수 없게 결과를 변형하는 것 -> 암호화
알아볼 수 없게 변형된 걸 원래값으로 -> 복호화
해시함수를 거치면 항상 똑같은 암호화된 값이 나온다.

ex)
secret => a3Sdg239ga (암호화)
a3Sdg239ga => secret(복호화)

1. 모든 값에 대해 해시 값을 계산하는데 오래걸리지 않아야 한다.
2. 최대한 해시 값을 피해야 하며, 모든 값은 고유한 해시값을 가진다.
3. 아주 작은 단위의 변경이라도 완전히 다른 해시값을 가져야 한다.

### salt

암호화해야 하는 값에 어떤 '별도의 값'을 추가하여 결과를 변형하는 것.

1. 암호화만 해놓는다면 해시된 결과가 늘 동일하다.
   해쉬된 값과 원래 값을 테이블(레인보우 테이블)로 만들어서 decoding해버리는 경우도 생긴다.
2. 원본값에 임의로 약속된 '별도의 문자열'을 추가하여 해시를 진행한다면 기존 해시값과 전혀 다른 해시값이 반환되어 알고리즘이 노출되더라도 원본값을 보호할 수 있도록 하는 안정 장치다.
3. 기존: 암호화하려는 값 -> 해시값
   salt사용: 암호화하려는 값 + salt용 값 -> 해시 값

해싱된값 --암호화--> 해싱된 값
해싱된값 --암호화--> 해싱된 값
해싱된값 --암호화--> 해싱된 값
여러번해서 안전하게 유지할 수 있다.
이렇게 여러번 해서 복잡도를 늘리는 방법
key derivation functions: salt와 hash를 여러번 해서 복잡도를 늘리는 방법 (crypt)

salt 주의사항

1. 유저와 패스워드 별로 유일한 값을 가져야 한다.
2. 사용자 계정을 생성할 때와 비밀번호를 변경할 때 마다 새로운 임의의 salt를 사용해서 해싱해야 한다.
3. 절대 재사용하지 말아야 한다.
4. DB의 유저 테이블에 같이 저장되어야 한다.

### cookies

서버가 브라우저에 전달하는 용도

어떤 내용이 전달될까?
로그인을 하고 성공했을때, set-cookie: session_id를 암호화해서 준다.
인증정보를 실어서, (쿠키를 삭제하거나 만료기간을 지정하지 않으면) 로그아웃이 안되게 만드는 것(상태유지)이 메인 목적이다.

첫 번째 요청후 서버가 클라이언트에게 일방적으로 쿠키를 전달한다.
헤더에 set-cookie: key=value

두번째 요청에서는 쿠키와 함께 요청이 전달된다.
헤더에 cookie:key=value; key2=value2

쿠키를 실어보내기 위해 fetch를 이용할까?
맞다. 쿠키는 헤더에 실려간다.

쿠키와 로컬스토리지는 다른 개념인가?

- 같은점: 브라우저에다 어떤 텍스트 정보를 저장하는 공간.
- 다른점:
  쿠키: 서버 -> 클라이언트 요청헤더에 같이 실린다.
  js로(httpOnly 경우에따라) 조작이 되긴한다.
  로컬스토리지: js로 언제든 내용을 심을 수 있다.

  자동로그인: 아이디, 패스워드를 어떤 브라우저 내 저장공간에 저장
